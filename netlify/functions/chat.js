// netlify/functions/chat.js
// Hibrid asszisztens: (1) bels≈ë tud√°s, (2) AI-only, (3) friss adatn√°l API/b√∂ng√©sz√©s.
// R√∂vid v√°lasz (max 2 mondat), legfeljebb 1 forr√°slink. SAFE m√≥d (nincs HTML-let√∂lt√©s ‚Üí nincs 502).

import OpenAI from "openai";
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function handler(event) {
  if (event.httpMethod === "OPTIONS") return { statusCode: 204, headers: cors() };

  try {
    const { message = "" } = JSON.parse(event.body || "{}");
    const question = (message || "").trim();
    if (!question) return json({ error: "√úres √ºzenet." }, 400);

    // 0) Smalltalk ‚Äì nincs b√∂ng√©sz√©s
    if (isGreeting(question)) {
      return json({
        ok: true,
        question,
        answer: "Szia! K√©rdezz b√°tran ‚Äî r√∂vid, l√©nyegre t√∂r≈ë v√°laszt adok, √©s ha kell, 1 megb√≠zhat√≥ forr√°st mutatok. üôÇ",
        meta: { smalltalk: true }
      });
    }

    // 1) FIX: r√≥lad / az oldalr√≥l sz√≥l√≥ k√©rd√©sek ‚Äì nincs b√∂ng√©sz√©s
    if (isOwnerQuestion(question)) {
      return json({
        ok: true,
        question,
        answer:
          "Az oldalt Horv√°th Tam√°s (Szabolcsb√°ka) k√©sz√≠tette, halad√≥ programoz√≥. Ha technikai k√©rd√©sed van az oldalr√≥l, √≠rd meg nyugodtan.",
        meta: { intent: "owner" }
      });
    }

    // 2) INTENT felismer√©s
    const intent = detectIntent(question);

    // 3) FRISS ADAT ‚Äì API vagy SAFE b√∂ng√©sz√©s, max 1 forr√°s
    if (intent === "fx") {
      const fx = await getFxRate(question);
      if (fx && fx.rate) {
        const answer =
          `(${fx.date}) ${fx.pair}: ${fx.rate.toFixed(2)}. Az √°rfolyam folyamatosan v√°ltozik.\n\n` +
          `Forr√°s: frankfurter.app\n${fx.sourceUrl}`;
        return json({ ok: true, question, answer, meta: { intent } });
      }
    }

    if (intent === "weather") {
      const wx = await getWeather(question);
      if (wx && wx.name) {
        const answer =
          `${wx.name} ${wx.dateLabel}: ${Math.round(wx.tMin)}‚Äì${Math.round(wx.tMax)}¬∞C${wx.pop != null ? `, csapad√©k es√©ly ~${wx.pop}%` : ""}. ` +
          `Az el≈ërejelz√©s rendszeresen friss√ºl.\n\n` +
          `Forr√°s: open-meteo.com\n${wx.sourceUrl}`;
        return json({ ok: true, question, answer, meta: { intent } });
      }
    }

    if (intent === "news") {
      // SAFE b√∂ng√©sz√©s ‚Äì 1 legjobb tal√°lat
      const best = await safeSearchBest(question);
      if (best) {
        const text = await answerFromSnippet(question, best.title, best.snippet);
        const answer =
          `${limitToTwoSentences(text)}\n\n` +
          `Forr√°s: ${hostname(best.link)}\n${best.link}`;
        return json({ ok: true, question, answer, meta: { intent, source: best.link } });
      }
      return json({ ok: true, question, answer: "Erre most nem tal√°ltam megb√≠zhat√≥, friss nyilv√°nos inform√°ci√≥t." });
    }

    // 4) ALAP/√ÅLTAL√ÅNOS K√âRD√âSEK ‚Äì AI-only (nincs b√∂ng√©sz√©s)
    {
      const text = await answerShortDirect(question);
      return json({ ok: true, question, answer: limitToTwoSentences(text), meta: { intent: "ai-only" } });
    }
  } catch (err) {
    return json({ error: err.message || String(err) }, 500);
  }
}

/* ============== Util ============== */
function cors() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
}
function json(body, statusCode = 200) {
  return { statusCode, headers: { "Content-Type": "application/json; charset=utf-8", ...cors() }, body: JSON.stringify(body, null, 2) };
}
const hostname = (u) => { try { return new URL(u).hostname.replace(/^www\./, ""); } catch { return ""; } };
function isValidHttpUrl(u) { try { const x = new URL(u); return x.protocol === "http:" || x.protocol === "https:"; } catch { return false; } }

function isGreeting(q) {
  const s = q.toLowerCase().trim();
  return ["szia","hali","hell√≥","hello","√ºdv","j√≥ napot","j√≥ est√©t","j√≥ reggelt"].some(p => s === p || s.startsWith(p + "!") || s.startsWith(p + "."));
}
function isOwnerQuestion(q) {
  return /ki k√©sz√≠tette|ki csin√°lta|k√©sz√≠t≈ë|fejleszt≈ë|tulaj|ki√© az oldal|k√©sz√≠tetted|horv√°th tam√°s/i.test(q);
}

function limitToTwoSentences(text) {
  const s = (text || "").replace(/\s+/g, " ").trim();
  const parts = s.split(/(?<=[.!?])\s+/).slice(0, 2);
  return parts.join(" ");
}

async function ask(messages) {
  const r = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    temperature: 0.2,
    messages
  });
  return r.choices?.[0]?.message?.content?.trim() || "";
}

/* ============== Intent ============== */
function detectIntent(q) {
  const s = q.toLowerCase();
  if (/\b√°rfolyam|eur(huf|huf)|eur√≥ √°rfolyam|usd huf|usd to huf|eur to huf\b/.test(s)) return "fx";
  if (/\bid≈ëj√°r√°s|meteo|el≈ërejelz√©s|weather|h≈ëm√©rs√©klet|holnap|ma\b/.test(s)) return "weather";
  if (/\bszt√°rbox|sztarbox|szt√°r box|h√≠r|breaking|legfrissebb|mi t√∂rt√©nt|r√©sztvev≈ëk|n√©vsor|versenyz≈ëk|2025\b/.test(s)) return "news";
  return "generic";
}

/* ============== AI-only (nincs b√∂ng√©sz√©s) ============== */
async function answerShortDirect(question) {
  const sys = "Adj magyarul maximum 2 mondatos, vil√°gos √©s pontos v√°laszt. Ne adj linket vagy forr√°slist√°t.";
  const user = `K√©rd√©s: ${question}`;
  return ask([{ role: "system", content: sys }, { role: "user", content: user }]);
}

/* ============== SAFE b√∂ng√©sz√©s (snippet) 1 linkkel ============== */
async function safeSearchBest(question) {
  const key = process.env.Google_API_KEY || process.env.GOOGLE_API_KEY;
  const cx  = process.env.Google_CX   || process.env.GOOGLE_CX;
  if (!key || !cx) return null;

  const url = new URL("https://www.googleapis.com/customsearch/v1");
  url.searchParams.set("key", key);
  url.searchParams.set("cx", cx);
  url.searchParams.set("q", question);
  url.searchParams.set("num", "8");
  url.searchParams.set("safe", "active");
  url.searchParams.set("hl", "hu");
  url.searchParams.set("gl", "hu");

  const res = await fetch(url);
  if (!res.ok) return null;
  const data = await res.json();
  const items = (data.items || [])
    .map(it => ({ title: it.title || "", snippet: it.snippet || "", link: it.link || "" }))
    .filter(it => isValidHttpUrl(it.link));

  if (!items.length) return null;

  // pontoz√°s: .hu √©s megb√≠zhat√≥ domain + aktu√°lis √©v + ‚Äûhivatalos‚Äù sz√≥
  const yearStr = String(new Date().getFullYear());
  const scoreDomain = (h) => ({
    "rtl.hu": 10, "24.hu": 9, "index.hu": 9, "telex.hu": 9, "hvg.hu": 9,
    "nemzetisport.hu": 8, "nso.hu": 8, "portfolio.hu": 9, "sportal.hu": 7,
    "blikk.hu": 6, "origo.hu": 6, "port.hu": 6, "nlc.hu": 6
  }[h] || (h.endsWith(".hu") ? 5 : 3));

  let best = null, bestScore = -1;
  for (const it of items) {
    const h = hostname(it.link);
    let s = scoreDomain(h);
    const urlLower = it.link.toLowerCase();
    if (urlLower.includes(yearStr)) s += 2;
    if (/\b2023\b|\b2024\b/.test(urlLower)) s -= 2;
    if (it.title.toLowerCase().includes("hivatalos")) s += 1;
    if (/facebook\.com|forum|hoxa|reddit|blogspot|wordpress/i.test(h)) s -= 3;
    if (s > bestScore) { best = it; bestScore = s; }
  }
  return best || items[0];
}

async function answerFromSnippet(question, title, snippet) {
  const sys =
    "Adj magyarul maximum 2 mondatos, konkr√©t v√°laszt a megadott r√∂vid forr√°sle√≠r√°s alapj√°n. " +
    "Ne tal√°lj ki √∫j t√©nyt, √©s ne adj forr√°slist√°t.";
  const user = `K√©rd√©s: ${question}\nForr√°s c√≠m: ${title}\nForr√°s le√≠r√°s: ${snippet}`;
  return ask([{ role: "system", content: sys }, { role: "user", content: user }]);
}

/* ============== FX (Frankfurter API) ============== */
async function getFxRate(q) {
  const m = q.toUpperCase().match(/([A-Z]{3})\s*\/?\s*([A-Z]{3})/);
  let from = "EUR", to = "HUF";
  if (m) { from = m[1]; to = m[2]; }

  const url = new URL("https://api.frankfurter.app/latest");
  url.searchParams.set("from", from);
  url.searchParams.set("to", to);

  const r = await fetch(url);
  if (!r.ok) return null;
  const d = await r.json(); // { date, rates: { HUF: 395.12 } }
  const rate = d?.rates?.[to];
  if (!rate) return null;

  return { pair: `${from}/${to}`, rate: Number(rate), date: d.date, sourceUrl: url.toString() };
}

/* ============== Weather (Open-Meteo API) ============== */
function stripHungarianCase(word) {
  const w = (word || "").toLowerCase().normalize("NFC");
  return w
    .replace(/[-\s]+/g, " ")
    .replace(/(?:ban|ben|ba|be|ra|re|rol|r√≥l|r≈ël|tol|t≈ël|nak|nek|on|en|√∂n|n|hoz|hez|h√∂z|ig|val|vel|k√©nt|n√°l|n√©l|ba|be)$/u, "");
}
function extractCityGuess(q) {
  const m = q.match(/([A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞][A-Za-z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞√°√©√≠√≥√∂≈ë√∫√º≈±\- ]{2,})/u);
  if (!m) return null;
  const base = stripHungarianCase(m[1].trim());
  const map = { "szabolcs": "Ny√≠regyh√°za", "szabolcs-szatm√°r-bereg": "Ny√≠regyh√°za", "pest": "Budapest" };
  const v = map[base.toLowerCase()] || (base[0].toUpperCase() + base.slice(1));
  return v;
}
async function getWeather(q) {
  const guess = extractCityGuess(q) || "Budapest";

  const geoUrl = new URL("https://geocoding-api.open-meteo.com/v1/search");
  geoUrl.searchParams.set("name", guess);
  geoUrl.searchParams.set("count", "1");
  geoUrl.searchParams.set("language", "hu");
  const geores = await fetch(geoUrl);
  if (!geores.ok) return null;
  const geodata = await geores.json();
  const loc = geodata?.results?.[0];
  if (!loc) return null;

  const lat = loc.latitude, lon = loc.longitude;
  const tz = loc.timezone || "Europe/Budapest";
  const wantTomorrow = /\bholnap|tomorrow\b/i.test(q);

  const wxUrl = new URL("https://api.open-meteo.com/v1/forecast");
  wxUrl.searchParams.set("latitude", String(lat));
  wxUrl.searchParams.set("longitude", String(lon));
  wxUrl.searchParams.set("daily", "temperature_2m_max,temperature_2m_min,precipitation_probability_max");
  wxUrl.searchParams.set("timezone", tz);
  wxUrl.searchParams.set("forecast_days", wantTomorrow ? "2" : "1");

  const wxres = await fetch(wxUrl);
  if (!wxres.ok) return null;
  const wx = await wxres.json();
  const d = wx?.daily;
  if (!d || !d.time?.length) return null;

  const idx = wantTomorrow && d.time.length > 1 ? 1 : 0;
  return {
    name: loc.name + (loc.country ? `, ${loc.country}` : ""),
    dateLabel: wantTomorrow ? "holnap" : "ma",
    tMin: d.temperature_2m_min?.[idx],
    tMax: d.temperature_2m_max?.[idx],
    pop: typeof d.precipitation_probability_max?.[idx] === "number" ? d.precipitation_probability_max[idx] : null,
    sourceUrl: wxUrl.toString()
  };
}
